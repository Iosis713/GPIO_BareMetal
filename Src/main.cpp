/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "../Inc/Gpio.hpp"
#include "../Inc/Button.hpp"
#include "../Inc/Timer.hpp"
#include "../Inc/Uart.hpp"
#include "../Inc/Config.hpp"
#include "../Inc/Pwm.hpp"
#include <stdio.h>
#include <cstring>

//drivers/cmsis/include/core_cm0plus////systick_config - method
//To Cortex system timer - in hal clock config

void ConfigurationButtonEXTI();
void TIM3_BaseConfiguration();
void TIM3_Start();
void TIM3_InterruptsConfiguration();
void TIM3_PWMConfiguration();
void LED_PWMPinSetup();
//from startup file
extern "C" void TIM3_IRQHandler(void);

GpioOutput<GPIOA_BASE, 5> ld2;
UART2<115200, 80> uart2;
PWM<GPIOA_BASE, 6, TIM3_BASE, (4 - 1), (1000 - 1)> pwmTIM3_CH1;

int main(void)
{
	SystemTimer::Init(4000);
	Button<GPIOC_BASE, 13, OptionsPUPDR::PullUp> userButton;
	ConfigurationButtonEXTI();
	LED_PWMPinSetup();
	Timer timerPWM(10);

	uart2.ConfigureExtiReceive();
	while (true)
	{

		if (uart2.GetStringIT() == ERROR_CODE::OK)
		{
			uart2.SendString(uart2.GetBuffer().data());

			if (strcmp(uart2.GetBuffer().data(), "set") == 0)
				ld2.Set();
			else if (strcmp(uart2.GetBuffer().data(), "clear") == 0)
				ld2.Clear();
			else if (strcmp(uart2.GetBuffer().data(), "toggle") == 0)
				ld2.Toggle();

			uart2.ClearBuffer();
		}

		if (timerPWM.IsExpired())
		{
			if (pwmTIM3_CH1.GetPulse_CH1() < pwmTIM3_CH1.GetMaxWidth() - 1)
				pwmTIM3_CH1.SetPulse_CH1(pwmTIM3_CH1.GetPulse_CH1() + 5);
			else
				pwmTIM3_CH1.SetPulse_CH1(0);
		}
	}
}

//PWM
//Timer clock - RM 6.2. Tim3 PCLK x1 or x2 -> TIMPCLK
//HPRE = 0x00 --> div 1
//PPRE1 = 0x00 --> div 1 (APB1PRE)

void TIM3_BaseConfiguration()
{
	//RM 6.4.19 APB1ENR
	RCC->APB1ENR1 |= RCC_APB1ENR1_TIM3EN; //1 enabled, 0 - disabled
	//TIMx_prescaler 16bit; RM 31.4.14 TIMx prescaler
	TIM3->PSC = (4 - 1);//1MHz
	//TIMx_auto-reloeadRegister - 16bit
	TIM3->ARR = (1000 - 1);//1kHz - defines top value for CNT register
	//CNT register hold current value of timers counter
}

void TIM3_Start()
{
	//TIMER counter register
	TIM3->CNT = 0;//reset if it had different value

	//RM 31.4.1 CEN bit (Counter enable)
	TIM3->CR1 |= TIM_CR1_CEN;
}

void TIM3_InterruptsConfiguration()
{
	//RM 31.4.4 DMA/Interrupt enable register (DIER)
	//Trigger interrupt enable TIE (on/off - 1/0)
	//Update interrupt enable UIE (on/off - 1/0)
	//update interrupt is enabled
	TIM3->DIER |= TIM_DIER_UIE;
	//capture/compare 1 interrupt 1 (CH1) enable
	TIM3->DIER |= TIM_DIER_CC1IE;

	//priority and enable in nvic
	//enum from stm32l476xx.h (CMSIS)
	NVIC_SetPriority(TIM3_IRQn, 1);
	NVIC_EnableIRQ(TIM3_IRQn);
}

void TIM3_PWMConfiguration()
{

	//RM 31.4.8 TIMx capture/compare mode register 1 (TIMx_CCMR1) [alternate] - output
	//Capture/Compare 1 Selection -CC1S - is output (0) by default, but check this bit
	//Output Compare 1 Mode - OC1M - PWM mode 1 -active when CNT < CCR1
	//0110  for PWM mode 1
	TIM3->CCMR1 |= TIM_CCMR1_OC1M_1;
	TIM3->CCMR1 |= TIM_CCMR1_OC1M_2;

	// Enable preload for CCR1 (this is **required** for PWM to work)
	TIM3->CCMR1 |= TIM_CCMR1_OC1PE;


	//RM 31.4.16 Capture/compare register 1
	//Capture compare register (to which value counter will be compared to set high state
	//its pulse value in other words
	//lets assume 50% = 499, as ARR = 999
	//this can be used to modify pulse
	TIM3->CCR1 = 500;
	//Capture/compare enable register (TIMx_CCER1) RM 31.4.11
	//capture/compare output enable bit
	TIM3->CCER |= TIM_CCER_CC1E;
}

void LED_PWMPinSetup()
{
	//enable clock for port A
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;
	//alternate 10
	GPIOA->MODER &= ~(GPIO_MODER_MODE6);//clear to 00
	GPIOA->MODER |= GPIO_MODER_MODE6_1;
	//Datasheet Pinouts and pin description
	//AF2 Datasheet Alternate functino 0 - 7

	//RM 8.5.10 GPIO alternate function low register (AFSEL6)
	//AF2 = 0010
	//GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL6_0);//0 by default anyway
	GPIOA->AFR[0] |= GPIO_AFRL_AFSEL6_1;
	//GPIOA->AFR[0] |= GPIO_AFRL_AFSEL6_2;
	//GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL6_3);//0 by default anyway
}


//RM EXTI
//RM External iterrupt/event GPIO Mapping (multiplexer)
//For single exti only single port
//I.e interrupt for PC13 cannot be set for PA13 at the same time
void ConfigurationButtonEXTI()
{
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; //enable SYSCFG clock
	//9.2.6 System configuration controller SYSCFG
	SYSCFG->EXTICR[3] &= ~SYSCFG_EXTICR4_EXTI13; //0000
	SYSCFG->EXTICR[3] |= SYSCFG_EXTICR4_EXTI13_PC; //set bit for PC13 exti route to syscfg

	//falling edge -> button normally opened -> high state
	//falls frop high state to low, when button is pressed
	EXTI->FTSR1 |= EXTI_FTSR1_FT13; //reference manual 14.5.3 Rising trigger selection register

	EXTI->IMR1 |= EXTI_IMR1_IM13;//unmasked
	//Interrupt mask register IMR
	//masked thing is treated as it does not exist

	//interrupt priority
	//enum from stm32l476xx.h (CMSIS file) - Interrupt number definition
	NVIC_SetPriority(EXTI15_10_IRQn, 1); //set priority (for exti 10 - 15, priotity = 1
	NVIC_EnableIRQ(EXTI15_10_IRQn);//enable interrupt
}

//interrupt handling function from start-up
//startup_stm32l476rgtx.s
//EXTI15_10_IRQHandler
extern "C" void EXTI15_10_IRQHandler(void)
{
	//which interrupt: status registers in RM 14.5.6 Pending register
	//PIFx --> PIF13
	//rc_w1 means - read, clear with 1
	if (EXTI->PR1 & EXTI_PR1_PIF13)
	{
		EXTI->PR1 |= EXTI_PR1_PIF13; //cleared by '1'
		ld2.Toggle();
	}
}

//startup_stm32l476rgtx.s
extern "C" void USART2_IRQHandler(void)
{
	uart2.IRQ_Handler();
	/*
	 * there should be long, time consuming operations
	 * flag can be enabled (data is ready to send/receive)
	 * uart can rise interrupt when data is ready to receive
	 * then add to buffer
	 * when the sign is  '\0' it can be send
	 */
}


extern "C" void TIM3_IRQHandler(void)
{
	pwmTIM3_CH1.InterruptHandler();
}

