/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "../Inc/Gpio.hpp"
#include "../Inc/Button.hpp"
#include "../Inc/Timer.hpp"
#include "../Inc/Uart.hpp"
#include "../Inc/Config.hpp"
#include "../Inc/Pwm.hpp"
#include "../Inc/Adc.hpp"
#include "../Inc/Spi.hpp"
#include "../Inc/Mcp23S08.hpp"
#include <stdio.h>
#include <cstring>

//drivers/cmsis/include/core_cm0plus////systick_config - method
//To Cortex system timer - in hal clock config

//void ConfigurationButtonEXTI();
//from startup file
extern "C" void TIM3_IRQHandler(void);
void Delay(const uint32_t delay);

GpioOutput<GPIOA_BASE, 5> ld2;
UART2<115200, 80> uart2;

int main(void)
{
	SystemTimer::Init(4000);


	/////////////////////////////////////////////
	/////_______________SPI_______________///////
	EnableSpiClocks();

	GpioOutput<GPIOA_BASE, 6> ioexp_cs;
	ioexp_cs.Set(); //high by defualt;
	//Datasheet 4 - Pinouts and pin description, table 17
	GpioAlternate<GPIOC_BASE, 2, AlternateFunction::AF5> spi2MISO;
	GpioAlternate<GPIOC_BASE, 3, AlternateFunction::AF5> spi2MOSI;
	GpioAlternate<GPIOB_BASE, 10, AlternateFunction::AF5> spi2SCK;
	SpiConfig();

	Delay(10);

	//enable GP0 as output
	McpWriteRegister(ioexp_cs, MCP23S08::IOCON, 0x00);
	McpWriteRegister(ioexp_cs, MCP23S08::IODIR, 0xFE);
	McpWriteRegister(ioexp_cs, MCP23S08::GPPU, MCP23S08::GP1); //pull-up for GP1 - button
	char buffer[64] = "Program starts here:";
	uart2.SendString(buffer);

	while (true)
	{
		if ((McpReadRegister(ioexp_cs, MCP23S08::GPIO) & MCP23S08::GP1) == 0)
			McpWriteRegister(ioexp_cs, MCP23S08::OLAT, 0x01);
		else
			McpWriteRegister(ioexp_cs, MCP23S08::OLAT, 0x00);
		/*
		McpWriteRegister(ioexp_cs, MCP_OLAT, 0x01);
		uint8_t olat = McpReadRegister(ioexp_cs, MCP_OLAT);
		snprintf(buffer, sizeof(buffer), "OLAT = 0x%02X", olat);
		uart2.SendString(buffer);
		Delay(500);

		McpWriteRegister(ioexp_cs, MCP_OLAT, 0x00);
		olat = McpReadRegister(ioexp_cs, MCP_OLAT);
		snprintf(buffer, sizeof(buffer), "OLAT = 0x%02X", olat);
		uart2.SendString(buffer);
		Delay(500);*/
	}
}



//interrupt handling function from start-up
//startup_stm32l476rgtx.s
//EXTI15_10_IRQHandler
extern "C" void EXTI15_10_IRQHandler(void)
{
}

//startup_stm32l476rgtx.s
extern "C" void USART2_IRQHandler(void)
{
	uart2.IRQ_Handler();
	/*
	 * there should be long, time consuming operations
	 * flag can be enabled (data is ready to send/receive)
	 * uart can rise interrupt when data is ready to receive
	 * then add to buffer
	 * when the sign is  '\0' it can be sendd
	 */
}


extern "C" void TIM3_IRQHandler(void)
{
	//pwmTim3.InterruptHandler();
	//channel1.InterruptHandler();
}

void Delay(const uint32_t delay)
{
	const uint32_t startTime = SystemTimer::Now();
	while(SystemTimer::Now() < startTime + delay)
	{
		//just wait
	}
}

