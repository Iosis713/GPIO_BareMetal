/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "../Inc/Gpio.hpp"
#include "../Inc/Button.hpp"
#include "../Inc/Timer.hpp"
#include "../Inc/Uart.hpp"
#include "../Inc/Config.hpp"
#include "../Inc/Pwm.hpp"
#include "../Inc/Adc.hpp"
#include "../Inc/Spi.hpp"
#include "../Inc/Mcp23S08.hpp"
#include "../Inc/LCD_TFT_ST7735S.hpp"
#include "../Inc/I2C.hpp"
#include <stdio.h>
#include <cstring>

//drivers/cmsis/include/core_cm0plus////systick_config - method
//To Cortex system timer - in hal clock config

//from startup file
extern "C" void TIM3_IRQHandler(void);

void ExampleUseOfTFTDisplayST7735S(auto& LCD_CS, auto& LCD_RST, auto& LCD_DC, auto& spi);

GpioOutput<GPIOA_BASE, 5> ld2;
UART2<115200, 80> uart2;

PWM<TIM3_BASE, (4 - 1), (1000 - 1)> pwmTim3(1);
PWMChannel<GPIOA_BASE, 6, 1> channel1(pwmTim3.Timer(), AlternateFunction::AF2);
Button<GPIOC_BASE, 13, OptionsPUPDR::PullUp> userButton;

int main(void)
{
	SystemTimer::Init(4000);

	/*
	userButton.ConfigureEXTI<2>(Trigger::Falling);
	Timer timerPWM(10);
	Timer timerADCPrint(250);

	Adc<ADC1_BASE, 2> adc1;
	AdcChannel<GPIOC_BASE, 0, 1> adcChannel1(adc1.ADC(), 1);
	AdcChannel<GPIOC_BASE, 1, 2> adcChannel2(adc1.ADC(), 2);
	uart2.ConfigureExtiReceive();
	*/

	/////////////////////////////////////////////
	/////_______________SPI_______________///////
	//GpioOutput<GPIOB_BASE, 12> LCD_CS;
	//GpioOutput<GPIOB_BASE, 2> LCD_RST;
	//GpioOutput<GPIOB_BASE, 11> LCD_DC; //command (0) /data (1) transmit

	//Datasheet 4 - Pinouts and pin description, table 17
	//GpioAlternate<GPIOC_BASE, 2, AlternateFunction::AF5> spi2MISO;
	//[[maybe_unused]] SpiPinsHalfDuplexTX<SpiSCK::SPI2_PB10_AF5, SpiMOSI::SPI2_PC3_AF5> spi2HalfDuplexTXPins;
	//LCD_CS.Set();

	//Spi<SPI2_BASE, SpiMode::HalfDuplex> spi2;
	//ExampleUseOfTFTDisplayST7735S(LCD_CS, LCD_RST, LCD_DC, spi2);

	/* MCP23S08
	//enable GP0 as output
	McpWriteRegister(ioexp_cs, MCP23S08::IOCON, 0x00);
	McpWriteRegister(ioexp_cs, MCP23S08::IODIR, 0xFE);
	McpWriteRegister(ioexp_cs, MCP23S08::GPPU, MCP23S08::GP1); //pull-up for GP1 - button
	char buffer[64] = "Program starts here:";
	uart2.SendString(buffer);
	/////_______________SPI_______________///////
	/////////////////////////////////////////////

	//McpWriteRegister(LCD_CS, MCP23S08::IOCON, 0x00);
	//McpWriteRegister(LCD_CS, MCP23S08::IODIR, 0xFE);
	//McpWriteRegister(LCD_CS, MCP23S08::GPPU, MCP23S08::GP1); //pull-up for GP1 - button
	//uart2.SendString(buffer);
	 */


	////////////////////////////////////////////////////////////
	//////___________________I2C__________________________//////

	GpioAlternate<GPIOB_BASE, 6, AlternateFunction::AF4, OptionsOTYPER::OpenDrain> i2c1SCL;
	GpioAlternate<GPIOB_BASE, 7, AlternateFunction::AF4, OptionsOTYPER::OpenDrain> i2c1SDA;

	I2C i2c1;
	static constexpr uint8_t deviceAddress = 0xA0;
	static constexpr uint8_t memoryAddress = 0x10;
	const uint8_t testData = 90;
	uint8_t readResult = 0;

	i2c1.WriteMemory(deviceAddress, memoryAddress, &testData, 1);
	Delay(5);
	i2c1.ReadMemory(deviceAddress, memoryAddress, &readResult, 1);
	//////___________________I2C__________________________//////
	////////////////////////////////////////////////////////////



	Timer ld2Timer(200);
	while (true)
	{
		if (ld2Timer.IsExpired())
			ld2.Toggle();

		////////////////_____SPI_____////////////////
		/*
		// MCP23S08
		if ((McpReadRegister(ioexp_cs, MCP23S08::GPIO) & MCP23S08::GP1) == 0)
			McpWriteRegister(ioexp_cs, MCP23S08::OLAT, 0x01);
		else
			McpWriteRegister(ioexp_cs, MCP23S08::OLAT, 0x00);
		*/
		////////////////_____SPI_____////////////////

		////////////////_____UART/GPIO EXTI_____////////////////
		/*
		if (uart2.GetStringIT() == ERROR_CODE::OK)
		{
			uart2.SendString(uart2.GetBuffer().data());

			if (strcmp(uart2.GetBuffer().data(), "set") == 0)
				ld2.Set();
			else if (strcmp(uart2.GetBuffer().data(), "clear") == 0)
				ld2.Clear();
			else if (strcmp(uart2.GetBuffer().data(), "toggle") == 0)
				ld2.Toggle();

			uart2.ClearBuffer();
		}
		*/
		////////////////_____UART/GPIO EXTI_____////////////////

		////////////////_____ADC_____////////////////
		/*
		adc1.StartConversion();
		adcChannel1.Read();
		adc1.StartConversion();
		adcChannel2.Read();

		if (timerADCPrint.IsExpired())
		{
			char buffer[64];
			snprintf(buffer, sizeof(buffer), "ADC channel 1: %lu, ADC channel 2: %lu\n", static_cast<unsigned long>(adcChannel1.Get()), static_cast<unsigned long>(adcChannel2.Get()));
			uart2.SendString(buffer);
		}

		if (timerPWM.IsExpired())
		{
			if (channel1.GetPulse() < pwmTim3.GetMaxWidth() - 1)
				channel1.SetPulse(channel1.GetPulse() + 5);
			else
				channel1.SetPulse(0);
		}
		*/
		////////////////_____ADC_____////////////////

		////////////////_____GPIO EXTI_____////////////////
		/*
		if (userButton.InterruptOccured())
		{
			ld2.Toggle();
			userButton.ClearInterruptFlag();
		}
		*/
		////////////////_____GPIO EXTI_____////////////////
	}
}


//interrupt handling function from start-up
//startup_stm32l476rgtx.s
//EXTI15_10_IRQHandler
extern "C" void EXTI15_10_IRQHandler(void)
{
	userButton.IrqHandler();
}

//startup_stm32l476rgtx.s
extern "C" void USART2_IRQHandler(void)
{
	uart2.IRQ_Handler();
	/*
	 * there should be long, time consuming operations
	 * flag can be enabled (data is ready to send/receive)
	 * uart can rise interrupt when data is ready to receive
	 * then add to buffer
	 * when the sign is  '\0' it can be sendd
	 */
}


extern "C" void TIM3_IRQHandler(void)
{
	pwmTim3.InterruptHandler();
	channel1.InterruptHandler();
}


void ExampleUseOfTFTDisplayST7735S(auto& LCD_CS, auto& LCD_RST, auto& LCD_DC, auto& spi)
{
	//TFTDisplay_ST7735S
	LCDInit(LCD_RST, LCD_DC, LCD_CS, spi);

	LCDFillBox(LCD_DC, LCD_CS, spi, 0, 0, 160, 16, RED);
	LCDFillBox(LCD_DC, LCD_CS, spi, 0, 16, 160, 16, GREEN);
	LCDFillBox(LCD_DC, LCD_CS, spi, 0, 32, 160, 16, BLUE);
	LCDFillBox(LCD_DC, LCD_CS, spi, 0, 48, 160, 16, YELLOW);
	LCDFillBox(LCD_DC, LCD_CS, spi, 0, 64, 160, 16, MAGENTA);
	LCDFillBox(LCD_DC, LCD_CS, spi, 0, 80, 160, 16, CYAN);
	LCDFillBox(LCD_DC, LCD_CS, spi, 0, 96, 160, 16, WHITE);
	LCDFillBox(LCD_DC, LCD_CS, spi, 0, 112, 160, 16, BLACK);

	std::array<uint16_t, 64 *64> testImage;
	for (auto& pixel : testImage)
		pixel = BLUE;

	LCDDrawImage(LCD_DC, LCD_CS, spi, 0, 0, 64, 64, testImage);
	LCDDrawImage(LCD_DC, LCD_CS, spi, 16, 16, 64, 64, testImage);
	LCDDrawImage(LCD_DC, LCD_CS, spi, 32, 32, 64, 64, testImage);
	LCDDrawImage(LCD_DC, LCD_CS, spi, 48, 48, 64, 64, testImage);
	LCDDrawImage(LCD_DC, LCD_CS, spi, 64, 64, 64, 64, testImage);

	for (int i = 0; i < 128; i++)
	{
		LCDPutPixel(i, i, RED);
		LCDPutPixel(127 - i, i, RED);
	}


	for (int y = 0; y < LCD_HEIGHT; y++)
	{
	  for (int x = 0; x < LCD_WIDTH; x++)
	  {
		  LCDPutPixel(x, y, (x / 10 + y * 16));
	  }
	}

	LCDCopy(LCD_DC, LCD_CS, spi);
}

