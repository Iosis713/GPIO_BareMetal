/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "../Inc/Gpio.hpp"
#include "../Inc/Button.hpp"
#include "../Inc/Timer.hpp"
#include "../Inc/Uart.hpp"
#include "../Inc/Config.hpp"
#include "../Inc/Pwm.hpp"
#include <stdio.h>
#include <cstring>

//drivers/cmsis/include/core_cm0plus////systick_config - method
//To Cortex system timer - in hal clock config

//void ConfigurationButtonEXTI();
//from startup file
extern "C" void TIM3_IRQHandler(void);
void Delay(const uint32_t delay);
void ADCConfig();
void ADCInputGPIOConfigure(); //ADC12_IN5 for PA0
void ADCConversion();
uint32_t ADCReadData();

GpioOutput<GPIOA_BASE, 5> ld2;
UART2<115200, 80> uart2;
PWM<TIM3_BASE, (4 - 1), (1000 - 1)> pwmTim3(1);
PWMChannel<GPIOA_BASE, 6, 1> channel1(pwmTim3.Timer(), AlternateFunction::AF2);
Button<GPIOC_BASE, 13, OptionsPUPDR::PullUp> userButton;

static volatile uint32_t adcSample = 0;

int main(void)
{
	SystemTimer::Init(4000);
	userButton.ConfigureEXTI<2>(Trigger::Falling);
	Timer timerPWM(10);
	Timer timerADCPrint(500);

	ADCInputGPIOConfigure();
	ADCConfig();

	//Channel selection? maybe in C0 it works in other way

	uart2.ConfigureExtiReceive();

	while (true)
	{
		/*if (uart2.GetStringIT() == ERROR_CODE::OK)
		{
			uart2.SendString(uart2.GetBuffer().data());

			if (strcmp(uart2.GetBuffer().data(), "set") == 0)
				ld2.Set();
			else if (strcmp(uart2.GetBuffer().data(), "clear") == 0)
				ld2.Clear();
			else if (strcmp(uart2.GetBuffer().data(), "toggle") == 0)
				ld2.Toggle();

			uart2.ClearBuffer();
		}*/
		ADCConversion();
		adcSample = ADCReadData();


		if (timerADCPrint.IsExpired())
		{
			char buffer[64];
			snprintf(buffer, sizeof(buffer), "ADC read: %lu", static_cast<unsigned long>(adcSample));
			uart2.SendString(buffer);
		}

		if (timerPWM.IsExpired())
		{
			if (channel1.GetPulse() < pwmTim3.GetMaxWidth() - 1)
				channel1.SetPulse(channel1.GetPulse() + 5);
			else
				channel1.SetPulse(0);
		}

		if (userButton.InterruptOccured())
		{
			ld2.Toggle();
			userButton.ClearInterruptFlag();
		}
	}
}

void ADCConfig()
{
	//RM 6.4.17 AHB peripheral clock enable register (AHB2ENR)
	RCC->AHB2ENR |= RCC_AHB2ENR_ADCEN;

	RCC->CCIPR |= RCC_CCIPR_ADCSEL_0 | RCC_CCIPR_ADCSEL_1; //system clock RM 6.4.28 Peripherals independent clock configuration register

	//proper voltage regulator enable:
	//RM 18.7.3 ADC volate regulator enable (ADVREGEN)
	//Check which ADC you're using In Datasheet pinouts and pin description
	//I.e PA0 ADC12_IN5 means it's available for ADC1 and ADC2, channel 5
	ADC1->CR &= ~ADC_CR_DEEPPWD;
	ADC1->CR |= ADC_CR_ADVREGEN; //ADC1
	//Delay(10); // 10 ms
	//Continous conversion mode for DMA and ADC cooperation
	//Sampling time (for how many ADC cycles measurement is being done)
	ADC1->SMPR1 |= ADC_SMPR1_SMP5_Msk; //RM 18.7.7 SMPx, 640.5 ADC cycles

	// Select HSI16 (16 MHz) as ADC clock source
	//RCC->CCIPR &= ~RCC_CCIPR_ADCSEL_Msk;
	//RCC->CCIPR |= (0b01 << RCC_CCIPR_ADCSEL_Pos); // 01: HSI16


	//prescaler for ADC -- lok for something like "common configuration register"
	//For stm32L476RG it's probably RM1 18.8.2 common control register (ADC_CCR) -- PRESC

	ADC1->CFGR |= ADC_CFGR_RES; //by default 12 bit resolution

	//Sequence for channel 5 in sequence 1
	ADC1->SQR1 &= ~ADC_SQR1_SQ1_Msk;
	ADC1->SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_2;
	//ADC1->SQR1 |= (5 << ADC_SQR1_SQ1_Pos);

	//Auto-calibration of ADC
	//RM 18.7.3 ADC Control rgister (CR)
	ADC1->CR |= ADC_CR_ADCAL;
	while (ADC1->CR & ADC_CR_ADCAL) {}; //need to wait until calibration is done
	ADC1->CR |= ADC_CR_ADEN;
	while (!(ADC1->ISR & ADC_ISR_ADRDY)) {}
}

//ADC12_IN5 for PA0
void ADCInputGPIOConfigure()
{
	//Enable clock for PA0
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;

	//GPIOA->MODER &= ~GPIO_MODER_MODE0; // Clear mode bits
	//GPIOA->MODER |= GPIO_MODER_MODE0; //analog (by default anyway)
	//OTYPER = 0 (pushPull by default)
	//OSPEEDR = 00 (Low speed by defualt)
	//PUPDR = 00 (no pullUp, no pullDown by default)
}

void ADCConversion()
{
	//RM 18.7.3 Control register
	while (ADC1->CR & ADC_CR_ADSTART) {}; //wait until it's done :(
	ADC1->CR |= ADC_CR_ADSTART;
	//uart2.SendString("ADSTART set");
	//but can be done better

	while (!(ADC1->ISR & ADC_ISR_EOC))
	{
		//uart2.SendString("waiting EOC...");
		Delay(50); // avoid flooding
	}; // wait until end of conversion

	//RM 18.7.1 Interrupt and status register (ISR)
	//EOC End of conversion flag - 0 - conversion not completed; 1 - regular channel conversion complete
	//cleared by writing 1 manually or reading ADC_DR
}

uint32_t ADCReadData()
{
	return ADC1->DR;
}

//interrupt handling function from start-up
//startup_stm32l476rgtx.s
//EXTI15_10_IRQHandler
extern "C" void EXTI15_10_IRQHandler(void)
{
	userButton.IrqHandler();
}

//startup_stm32l476rgtx.s
extern "C" void USART2_IRQHandler(void)
{
	uart2.IRQ_Handler();
	/*
	 * there should be long, time consuming operations
	 * flag can be enabled (data is ready to send/receive)
	 * uart can rise interrupt when data is ready to receive
	 * then add to buffer
	 * when the sign is  '\0' it can be send
	 */
}


extern "C" void TIM3_IRQHandler(void)
{
	pwmTim3.InterruptHandler();
	channel1.InterruptHandler();
}

void Delay(const uint32_t delay)
{
	const uint32_t startTime = SystemTimer::Now();
	while(SystemTimer::Now() < startTime + delay)
	{
		//just wait
	}
}

